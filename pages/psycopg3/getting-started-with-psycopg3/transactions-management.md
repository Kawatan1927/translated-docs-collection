### トランザクション管理

Psycopg は psql と比較すると一見意外に思える動作をします。デフォルトでは、あらゆるデータベース操作が新たなトランザクションを開始します。その結果、コネクション内のどのカーソルで行われた変更も、`Connection.commit()` が呼ばれるまで反映されず、`Connection.rollback()` が呼ばれると破棄されます。同じコネクションで次の操作が行われると、新たにトランザクションが開始されます。

もしデータベース操作が失敗すると、サーバはロールバックが行われるまで以降のコマンドを拒否します。

トランザクションが開始された状態でコネクションが閉じられる場合、COMMIT コマンドはサーバに送信されず、サーバ側でそのコネクションの変更は破棄されます。PgBouncer のような一部のミドルウェアは、トランザクション状態のまま残されたコネクションも破棄するため、可能であればコネクションを使い終える前に commit または rollback を実行することが望まれます。

#### 例

初めて Psycopg を使用したとき（そしてその動作にがっかりするかもしれない例）は、次のようになります：

```python
conn = psycopg.connect()

# カーソルを作成しても、トランザクションは開始されず、
# コネクションに影響はありません。
cur = conn.cursor()

cur.execute("SELECT count(*) FROM my_table")
# この関数呼び出しは次の操作を実行します:
# - BEGIN
# - SELECT count(*) FROM my_table
# これにより、トランザクションが開始されます。

# この状態でプログラムが長時間待機すると、
# サーバは「idle in transaction」の状態のコネクションを保持し続けますが、これは望ましくありません。

cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
# このステートメントは、トランザクション内で実行されます

conn.close()
# COMMIT が送信されなかったため、INSERT の変更は破棄されます。
```

上記の実行結果として、psql で確認するとテーブル `data` に新しいレコードが存在しないことが明らかです。この問題を解決するひとつの方法は、コネクションを閉じる前に `conn.commit()` を呼び出すことです。幸いなことに、コネクションコンテキストを使用すると、ブロックの終了時に自動的に commit（または例外発生時は rollback）が実行されるため、次のように書き換えることができます：

```python
with psycopg.connect() as conn:

    cur = conn.cursor()

    cur.execute("SELECT count(*) FROM my_table")
    # この関数呼び出しは次の操作を実行します:
    # - BEGIN
    # - SELECT count(*) FROM my_table
    # これにより、トランザクションが開始されます。

    cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
    # このステートメントは、トランザクション内で実行されます

# ブロックの終了時に例外が発生していなければ:
# COMMIT が実行されます。
```

この方法では、`close()` や `commit()` を個別に呼び出す必要がなくなり、データベース操作の変更が確実に永続化されます。ただし、注意すべきは最初の操作からコネクション終了までの間、トランザクションが維持される点です。トランザクションをより細かく制御したい場合は、オートコミットモードやトランザクションコンテキストを使用してください。

---

### 警告

デフォルトでは、単純な `SELECT` でさえトランザクションが開始されます。長時間動作するプログラムで何も対処しない場合、セッションは「idle in transaction」の状態になり、これはロックの保持やテーブルの膨張といった望ましくない影響を及ぼします。長時間実行されるスクリプトの場合は、できるだけ早くトランザクションを終了するか、オートコミットコネクションを使用してください。

#### ヒント

もしデータベース操作が次のようなエラーメッセージ（例：`InFailedSqlTransaction: current transaction is aborted, commands ignored until end of transaction block`）で失敗した場合は、直前の操作が失敗し、データベースセッションがエラー状態にあることを意味します。同じコネクションを引き続き使用するには、`rollback()` を呼び出す必要があります。

---

### オートコミットトランザクション

オートコミットモードを使用すると、手動でコミットする必要をなくすことができます。これは、`autocommit` をコネクション属性として、または `connect()` のパラメータとして設定することができます。オートコミットモードは、トランザクション内では実行できない操作（たとえば、`CREATE DATABASE`、`VACUUM`、トランザクション制御を伴うストアドプロシージャの `CALL` など）を実行する際に必要になる場合があります。

オートコミットモードでの操作は、次のようになります：

```python
with psycopg.connect(autocommit=True) as conn:

    cur = conn.cursor()

    cur.execute("SELECT count(*) FROM my_table")
    # この関数呼び出しは次の操作のみを実行します:
    # - SELECT count(*) FROM my_table
    # したがって、トランザクションは開始されません。

    cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
    # このステートメントの結果は、データベースにより即座に永続化されます

# ブロックの終了時にコネクションは閉じられますが、
# トランザクション状態にないため COMMIT は実行されません。
```

オートコミットモードの挙動は、psql に慣れ親しんだユーザの期待に近いものです。この設定により、発行されるクエリの数が減少し、データベースの処理負荷も軽減されます。ただし、ステートメントは原子的なトランザクション内で実行されないため、もし複数の操作を一括して原子性を保証する必要がある場合は、オートコミットモード下でも明示的なトランザクションブロックを使用することができます。

---

### トランザクションコンテキスト

トランザクションを適切なタイミングで確実に終了させる、より明示的な方法として `with Connection.transaction()` を利用したトランザクションコンテキストがあります。コンテキストに入るとトランザクションが開始され、コンテキストを抜ける際にコミットが実行され、ブロック内で例外が発生した場合はロールバックされます。

先ほどの例を続けると、オートコミットコネクションを使用しつつも、特定のコマンド群を原子的なトランザクション内にラップしたい場合は、以下のように `transaction()` コンテキストを利用できます：

```python
with psycopg.connect(autocommit=True) as conn:

    cur = conn.cursor()

    cur.execute("SELECT count(*) FROM my_table")
    # コネクションはオートコミットなので、BEGIN は実行されません。

    with conn.transaction():
        # BEGIN が実行され、トランザクションが開始されます

        cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
        cur.execute("INSERT INTO times VALUES (now())")
        # これら2つの操作は同一トランザクション内で原子的に実行されます

    # ブロック終了時に COMMIT が実行され、
    # コネクションは再びアイドル状態になります。

# ブロック終了時にコネクションが閉じられます。
```

なお、コネクションブロックはオートコミットでないコネクションでも利用可能です。その場合、明示的に開始された暗黙のトランザクションに注意が必要です。たとえば、以下のコードでは暗黙のトランザクションが開始され、その後の `transaction()` ブロックではセーブポイントによるサブトランザクションが管理され、ブロック終了時にセーブポイントのみが解放されるため、メインのトランザクションは引き続き継続されます。

```python
conn = psycopg.connect()

cur = conn.cursor()

cur.execute("SELECT count(*) FROM my_table")
# この関数呼び出しは次の操作を実行します:
# - BEGIN
# - SELECT count(*) FROM my_table
# これにより、トランザクションが開始されます。

with conn.transaction():
    # ブロック開始時、既にトランザクションが開始されているため、
    # SAVEPOINT が実行されます。

    cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))

# このブロックはサブトランザクションとして実行され、終了時に:
# - RELEASE SAVEPOINT が実行されます
# なお、メインのトランザクションは継続されます。

conn.close()
# COMMIT が送信されなかったため、INSERT の変更は破棄されます。
```

もしアクティブなトランザクションブロックを明示的にロールバックしたい場合は、`Rollback` 例外を発生させることが可能です。この例外は、現在のトランザクションブロックの終了まで「ジャンプ」し、そのトランザクションのみをロールバックしつつプログラムの実行を継続させます。デフォルトでは、例外は最も内側のトランザクションブロックをロールバックしますが、任意のブロックをターゲットにすることも可能です。以下は、仮想の `CancelCommand` によって処理を中止し、まだコミットされていないすべての操作をキャンセルする例です。

```python
from psycopg import Rollback

with conn.transaction() as outer_tx:
    for command in commands():
        with conn.transaction() as inner_tx:
            if isinstance(command, CancelCommand):
                raise Rollback(outer_tx)
            process_command(command)

# `Rollback` が発生した場合、このブロックまで例外が伝播し、
# プログラムは例外なくその後の処理を続行します。
```

---

### トランザクションの特性

Psycopg が管理するトランザクションに対して、各種トランザクションパラメータを設定することができます。これらのパラメータは、暗黙のトランザクション（オートコミットでない場合に自動的に開始されるもの）および `Connection.transaction()` によって明示的に開始されるトランザクションの両方に影響します。

#### 警告

トランザクションパラメータは、トランザクションコンテキストが明示的に使用されていない限り、オートコミットコネクションには影響しません。

これらのパラメータを `None` のままにしておくと、サーバのデフォルト動作（たとえば `default_transaction_isolation` などのサーバ設定によるもの）が利用されます。パラメータを設定するには、コネクション属性 `isolation_level`、`read_only`、`deferrable` を利用します。非同期コネクションの場合は、同等の `set_isolation_level()` メソッドなどを使用してください。なお、コネクション上にすでにアクティブなトランザクションが存在する場合は、パラメータの変更はできません。

バージョン 3.2 以降では、同期コネクションでも同等のプロパティ設定（たとえば `set_isolation_level()`）が追加されました。

#### 警告

`REPEATABLE_READ` または `SERIALIZABLE` の隔離レベルで動作するアプリケーションは、シリアライゼーション失敗のリスクにさらされます。並行更新が発生した場合、PostgreSQL は以下のような例外を発生させることがあります：

```
psycopg2.errors.SerializationFailure: could not serialize access
due to concurrent update
```

この場合、例外を引き起こした操作を再実行する準備が必要です。

---

### 二相コミットプロトコルのサポート

（バージョン 3.1 以降）

Psycopg は、DBAPI に提案された二相コミット拡張を実装することで、PostgreSQL が提供する二相コミット機能にアクセスできるようにしています。

DBAPI の二相コミットモデルは、XA 仕様に着想を得ており、トランザクション ID は以下の 3 つの要素から構成されます：

- フォーマット ID（非負の 32 ビット整数）
- グローバルトランザクション ID（64 バイト以内の文字列）
- ブランチ修飾子（64 バイト以内の文字列）

特定のグローバルトランザクションでは、最初の 2 つの要素はすべてのリソースで共通となり、各リソースには異なるブランチ修飾子が割り当てられます。

DBAPI 仕様に従い、トランザクション ID は `Connection.xid()` メソッドを使用して生成されます。一度トランザクション ID が得られれば、`Connection.tpc_begin()` により分散トランザクションを開始し、`tpc_prepare()` で準備、`tpc_commit()` または `tpc_rollback()` により完了させることができます。また、トランザクション ID は `tpc_recover()` を使用してデータベースから取得でき、取得後は上記の `tpc_commit()` や `tpc_rollback()` を用いて完了させることができます。

なお、PostgreSQL は XA 標準には従っておらず、PostgreSQL 用の準備済みトランザクションの ID は 200 文字以内の任意の文字列となります。Psycopg の `Xid` オブジェクトは、`xid()` メソッドで生成される XA スタイルのトランザクション ID と、未解析の文字列による PostgreSQL のトランザクション ID の両方を表現できます。

Xid がデータベースに渡される文字列への変換形式は、PostgreSQL の JDBC ドライバが使用しているものと同じであるため、Python と Java で書かれたツール間での相互運用が可能となります。たとえば、Python で書かれたリカバリツールは、Java プログラムによって生成されたトランザクションの構成要素を認識できるでしょう。

詳細については、二相コミットサポートメソッドのドキュメントを参照してください。
